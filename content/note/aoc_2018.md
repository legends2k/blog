+++
title = "Advent of Code Experience"
description = "Puzzling for fun and profit"
date = 2022-09-18T19:55:57+05:30
tags = [ "tech", "introspection" ]
+++

I completed [Advent of Code][aoc] (AoC) 2018 today.  Itâ€™s a puzzle jam: yearly from Dec 1 to 25 a couple of puzzles are published everyday.  Itâ€™s [popular][] in geek circles; folks solve them in winter when business is dull.  Leaderboards are filled with people who solve them well within the release day.  There arenâ€™t any restrictions on when or how you solve these puzzles.

This piece shares my experience for the general computer programmer.

[aoc]: https://adventofcode.com/
[popular]: https://hn.algolia.com/?q=advent+of+code

# Code

I used [Rust][] but that isnâ€™t the subject of this article.  Hereâ€™s my repo:

https://github.com/legends2k/advent-of-code/tree/master/2018

Iâ€™ve peppered the code with enough comments.  My commit logs usually capture context which canâ€™t be added as comments.

I donâ€™t like shortcuts like hard-coding puzzle inputs, keeping everything as strings, etc.  I tried to make the code fast, within reason, by being disciplined.  **Iâ€™ve tried my best to make everything structured without [yak shaving][]**.

[Raise a bug][bug] if you want to discuss something.

[yak shaving]: https://en.wiktionary.org/wiki/yak_shaving
[bug]: https://github.com/legends2k/advent-of-code/issues/new

# History

I motivated a couple of friends to join me in trying AoC around 2020 Feb.  **Little did we know about the then-imminent pandemic**.  A month from our start weâ€™re deep in lock-downs, procuring grocery like paramilitary, setting up home offices and mini-schools, ...

We agreed on completing one puzzle/week since weâ€™re married with kids.  We thought itâ€™s a reasonable target given these puzzles are solved in a day by so many.  How wrong were we! ðŸ¤£

**Nevertheless we ploughed whenever we got free time.**

# Complete 'em!

> How fast you complete the puzzles doesnâ€™t matter much than the completion itself.

__Iâ€™ve no shame in admitting it took 2Â½ years for me to complete what people do in 25 days.  Iâ€™m glad I completed them__.  I didnâ€™t have a regular schedule since life intervened, multiple times (some quite serious like death, relocation, etc. apart from the pandemic).  **Whenever I found time, I solved small parts** of a puzzle.  For instance, parsing the input itself was quite a challenge for [a puzzle](#day-24), I took a couple of days (an hour each) and solved it.

Maintaining perspective is important as always.  If Iâ€™m doing it for fun (and knowledge), whatâ€™s the point in trying to rush with a false deadline and pressurize myself?  The other extreme is to be so lax I lose interest and not complete.  While thereâ€™s nothing inherently wrong about this, if I repeat this for all my endeavours, Iâ€™m not going to get to any decent level of proficiency with any tool/concept with a bunch of unfinished projects.  Let aside mastery, Iâ€™d not have stories to tell or experiences to gain with that style of working.

**The balance is to complete the project at your own pace while preventing burning outs.**

# Cheating to learn

I completed _almost_ all puzzles on my own.  IIRC, I cheated for 2-3 puzzles; looked up someoneâ€™s solution.  Itâ€™s important to know when:

> I cheated when all other options are exhausted and I realized Iâ€™m stuck long enough on one puzzle to lose interest in AoC.

Since many had solved AoC 2018 by now, I looked around the forums ([r/adventofcode][r-aoc]), scoured Wikipedia articles on a data structures / algorithms and discussed with friends.  When I realized all my usual options led me no where, I turned to someoneâ€™s solution.  I didnâ€™t read them directly.  I usually ran them with my puzzle inputs and checked the correct answer against mine.  This helped me solve a puzzle without cheating.

Cheating instead of dropping the project altogether seems okay.  Itâ€™s okay if youâ€™re doing it for learning; not where youâ€™re proving your worth (e.g. exam).

[r-aoc]: https://www.reddit.com/r/adventofcode

# Takeaways

1. Developer time is more valuable than machine time
    - Some solutions I encountered took 10x more time to solve the same puzzle, but with a simpler approach and perhaps considerably lesser dev time.  Moreover the actual time taken would be in minutes while I spent days to arrive at my optimized structured solution.
2. Brute force solutions arenâ€™t as bad as you might think
    - Sometimes theyâ€™re the optimal solution given other parameters
    - Optimized solutions have poor ROI at times [relates to (1)]
3. Excessive polishing is a waste of time
    - Know when to stop; understand the _Law of Diminishing Returns_
4. Code regularly periodically to avoid becoming a rusty developer; important as you become a senior
    - Corporates donâ€™t care about your coding skills, only results
5. There are many awesome programmers out there; learn and admire
    - Iâ€™m humbled by some solutions I encountered

# References

After solving every puzzle, Iâ€™d fun going over solutions particularly of of Kanegae Gabriel and Andrew Gallant.  Respect and admiration for their work.

* [Kanegae Gabriel][] (Python)
* [Andrew Gallant][] a.k.a _BurntSushi_ (Rust)
* [Forrest Smith][] (Rust)
* [Todd Ginsberg][] (Kotlin)

[Kanegae Gabriel]: https://github.com/KanegaeGabriel/advent-of-code-2018
[Andrew Gallant]: https://github.com/BurntSushi/advent-of-code
[Forrest Smith]: https://www.forrestthewoods.com/blog/solving-advent-of-code-in-under-a-second/
[Todd Ginsberg]: https://todd.ginsberg.com/tags/adventofcode/

# Rust

I solved the puzzles in Rust.  Itâ€™s common for participants of AoC to pick a new language they wanted to get better at as the tool to solving the puzzles.  Iâ€™d been dabbling in Rust for more than 3 years now; done some [Rust exercises][exio-rust]; presented Rust sessions at my office.  Wanting to improve my [kata][] is only part reason.  I knew _BurntSushi_, author of [ripgrep][], has done AoC 2018; I wanted to compare my solutions to his after every puzzle completion ;)

I wrote functional style Rust using iterators wherever possible; itâ€™s terse and sound coding.  Thanks to [Exercism.io][] for teaching this early on.

{{< highlight rust >}}
box_ids
  .iter()
  .enumerate()
  .find_map(|(idx, s1)| {
    box_ids
      .iter()
      .skip(idx + 1)
      .find_map(|s2| fuzzy_intersection(s1, s2))
  })
{{< /highlight >}}

So have I mastered Rust now?  Nope; itâ€™s unneeded.  Whatâ€™s important is now Iâ€™m confident enough to reach for Rust when itâ€™s the right tool.  Iâ€™ve learned a bunch of concepts, techniques and standard library facilities I can employ in other projects.  I still have to learn about async, generics, etc. (unneeded for AoC).  Itâ€™s nice to have such backlogs to pursue.

[Rust]: https://www.rust-lang.org/
[exio-rust]: https://github.com/legends2k/exercism/tree/master/rust
[ripgrep]: https://github.com/BurntSushi/ripgrep
[kata]: {{< relref "programmer_kata.md" >}}
[Exercism.io]: https://exercism.org/tracks/rust

# Puzzles

This is the last section for a couple of reasons: (a) it might be uninteresting to non-participants (b) contains spoilers.

Some puzzles were very dry; questions werenâ€™t very good at explaining the problem[^1].  This was frustrating since the rules werenâ€™t properly laid out.

Hereâ€™re some notable puzzles and my learnings:

## Day 7

[Task scheduler][] puzzle involving a [dependency graph][] and [topological sort][].  I solved this using [dynamic array][] (`Vec`) instead of graph.  I did this by storing the dependants of a task, instead of its dependencies, and followed a push, instead of pull, model on task completions
.
Learned about authoring custom iterators in Rust.

[Task scheduler]: https://en.wikipedia.org/wiki/Scheduling_(computing)
[dependency graph]: https://en.wikipedia.org/wiki/Dependency_graph
[topological sort]: https://en.wikipedia.org/wiki/Topological_sorting
[dynamic array]: https://en.wikipedia.org/wiki/Dynamic_array

## Day 6

[Voronoi diagram][] calculation problem.  Involved coding up [flood fill][]-like algorithm.

[Voronoi diagram]: https://en.wikipedia.org/wiki/Voronoi_diagram
[flood fill]: https://en.wikipedia.org/wiki/Flood_fill

## Day 9

Computing hi-scores in a game between elves.  Wrote a `CircularList` using `Vec`.  Many solved this using `HashMap` but simple `Vec` is fairly versatile and under-used :)

## Day 10

Points move around on an infinitely large canvas frame-by-frame; at a point in time they form a bunch of characters just for a frame.  I wrote a 2D visualization to solve this but others had done this just on terminal.  Though a command-line junkie, I totally missed this!  Given my interests in graphics and game programming this is perhaps expected?

Also I missed to realize the bounding box of the entire data keeps shrinking and reaches its minimum when the characters are formed!  A good learning exercise.

_This was my longest hiatus_: resumed AoC after a 10 month break.

## Day 11

[Summed area table][] problem which I realized only after solving it using a semi-brute force approach.

[Summed area table]: https://en.wikipedia.org/wiki/Summed-area_table

## Day 12

[Genetic algorithm][] puzzle on plant growth.  Had fun using bit flags.  [Bit fiddling][] is becoming a lost art these days; it isnâ€™t esoteric once you understand the basic rules.

This is the start of puzzles where solutions can get stuck in infinite loops without a deterministic answer.  Iâ€™d to code bailing out of a loop if solutions didnâ€™t change across iterations.

[Genetic algorithm]: https://en.wikipedia.org/wiki/Genetic_algorithm
[Bit fiddling]: https://en.wikipedia.org/wiki/Bit_manipulation

## Day 13

Fun problem with [ASCII art][] input of carts spread across a map.  Weâ€™ve to simulate carts moving around with a set of rules to find if thereâ€™s a collision eventually.  A very satisfying problem!

[ASCII art]: https://en.wikipedia.org/wiki/ASCII_art

## Day 15

Mini [turn-based][] battle.  I gathered from the forums that many folks stopped AoC 2018 at this one.  It needs one to implement [shortest distance][pathing] path finding and meticulously follow a set of rules to find out the eventual victor.

I implemented BFS-based pathing.  The puzzle itself wasnâ€™t hard (skill-wise) but involved a lot of busy work following complicated rules meticulously. Though I struggled quite a bit, Iâ€™m proud that I got this right without help.

Day 14 was the start of poor puzzle descriptions.  This one was even more complicated and unclear.

[turn-based]: https://en.wikipedia.org/wiki/Turns,_rounds_and_time-keeping_systems_in_games#Turn-based
[pathing]: https://en.wikipedia.org/wiki/Shortest_path_problem

## Day 16

[Virtual machine][vm] implementation running ElfCode, a made-up [instruction set][isa].  This was fun!  VM created here is used in later puzzles with more complications.  It roused the assembly programmer in me; it all came back!

[vm]: https://en.wikipedia.org/wiki/Virtual_machine
[isa]: https://en.wikipedia.org/wiki/Instruction_set_architecture

## Day 17

A simulation of liquid flow filling reservoirs.  This was quite hard.  My continuous approach was futile; resorted to a discrete approach and solved it.

Unlike most mine was an iterative solution but super slow (810 ms).  Numerous small memory allocations was the culprit; pre-allocating memory lead to a 9x speed up (89 ms).  [Start pre-allocating and stop worrying][prealloc]!

[prealloc]: https://gamesfromwithin.com/start-pre-allocating-and-stop-worrying

## Day 18

[Conwayâ€™s Game of Life][gol] puzzle.  Fun!

Part 2 of the puzzle required running the simulation for 1 billion times.  This had to short-circuited.  Printing the generated sequences showed a repetition of the results with periodicity; I vaguely remember cheating for this.

[gol]: https://en.wikipedia.org/wiki/Conway%27s_Game_of_Life

## Day 19

Another ElfCode assembly puzzle.  It involved understanding why assembly code was stuck in a loop.  Basically itâ€™s trying to [factorize a large integer][factorize] inefficiently.  Weâ€™d to replace this ElfCode segment with our own routines.

Used the opportunity to learned about Rust modules and wrote a generic [Cartesian product][Cartesian] function.

[factorize]: https://en.wikipedia.org/wiki/Integer_factorization
[Cartesian]: https://en.wikipedia.org/wiki/Cartesian_product

## Day 20

Shortest distance path finding problem whose input is a very long regular expression.  Iâ€™m glad I didnâ€™t resort to any regex libraries as itâ€™s fairly easy to parse it â€˜by handâ€™.  I solved by implementing BFS for the shortest path algorithm reusing stuff from day 15.  Realized that many solutions were a lot simpler than mine; no path finding at all!

## Day 22

Path finding problem with constraints and edge costs.  Another hard problem with lots of rules and corner cases like day 15.  I cheated for this by getting inspirations from other solutions.

## Day 23

[Nearest neighbour search][] similar to the [Closest Pair][ccp] and [Largest Empty Circle][lep] ([Computational Geometry][]) problems.  Given a bunch of scattered spheres find the point such itâ€™s closest to as many spheres as possible! ðŸ˜±

Tried brute force approach in vain.  Solved by implementing [Octree][].  Very unsatisfying problem; despite coding it using integers then with floats, an [off-by-one][] error plagued my solution.

[Computational Geometry]: https://en.wikipedia.org/wiki/Computational_geometry
[Nearest neighbour search]: https://en.wikipedia.org/wiki/Nearest_neighbor_search
[ccp]: https://en.wikipedia.org/wiki/Closest_pair_of_points_problem
[lep]: https://en.wikipedia.org/wiki/Largest_empty_circle
[Octree]: https://en.wikipedia.org/wiki/Octree
[off-by-one]: https://en.wikipedia.org/wiki/Off-by-one_error#Fencepost_error

## Day 24

Another turn-based war puzzle.  The input was fairly complicated and most resorted to hard coding their input and some used regular expression libraries.  I used this opportunity to learn [Parsing Expression Grammar][peg] (PEG) and it worked quite well!  Thanks to [Leafo][] for introducing me to PEGs and [pest][] for such a nice Rust implementation.

[peg]: https://en.wikipedia.org/wiki/Parsing_expression_grammar
[leafo]: https://leafo.net/guides/parsing-expression-grammars.html
[pest]: https://pest.rs/

## Day 25

Very satisfying [Union-Find][] problem I implemented using `HashMap`.

[Union-Find]: https://en.wikipedia.org/wiki/Disjoint_set_data_structure

# Conclusion

I thoroughly enjoyed Advent of Code and learned a bunch of things along the way.  Time permitting I might try another with a different tool.

[^1]: I might be wrong as a non-native speaker
